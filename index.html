<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic Breakout Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif; /* Apply futuristic font */
            background-color: #0a0a1a; /* Very dark blue/black background */
            color: #e0e0e0; /* Light grey text */
            padding-top: 70px; /* Add padding below fixed navbar */
        }

        /* Style the navbar */
        .navbar {
            background-color: rgba(10, 10, 30, 0.8); /* Semi-transparent dark blue */
            backdrop-filter: blur(8px); /* Frosted glass effect */
            border-bottom: 1px solid #00ffff; /* Cyan border */
            box-shadow: 0 0 10px #00ffff; /* Neon glow */
        }

        .navbar-brand {
            color: #00ffff !important; /* Cyan brand text */
            text-shadow: 0 0 5px #00ffff;
        }

        .nav-link {
             color: #c0c0ff !important; /* Light purple-blue links */
        }
        .nav-link.active {
            color: #ffffff !important; /* White active link */
        }

        /* Style the game canvas */
        #gameCanvas {
            display: block;
            margin: 20px auto; /* Center canvas horizontally */
            background-color: #1a1a2a; /* Dark blue canvas background */
            border: 2px solid #00ffff; /* Cyan border */
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px rgba(0, 255, 255, 0.3); /* Outer and inner neon glow */
            max-width: 100%; /* Ensure canvas fits container */
            height: auto; /* Maintain aspect ratio */
            border-radius: 8px; /* Slightly rounded corners */
        }

        /* Style game controls */
        .game-controls button {
            margin: 5px 10px;
            border-radius: 25px; /* More rounded buttons */
            transition: all 0.3s ease;
            font-weight: bold;
            border: none; /* Remove default border */
            padding: 10px 25px;
            font-size: 1.1rem;
        }

        /* Custom button styles */
        #startButton {
             background: linear-gradient(45deg, #00ffff, #007bff); /* Cyan to Blue gradient */
             color: #000;
             box-shadow: 0 0 8px #00ffff;
        }
         #startButton:hover {
             transform: scale(1.05);
             box-shadow: 0 0 15px #00ffff;
         }

         #resetButton {
             background: linear-gradient(45deg, #ff00ff, #6f42c1); /* Magenta to Indigo gradient */
             color: #fff;
             box-shadow: 0 0 8px #ff00ff;
         }
          #resetButton:hover {
             transform: scale(1.05);
             box-shadow: 0 0 15px #ff00ff;
         }

        /* Center container and limit width */
         .container {
            max-width: 960px; /* Limit width for better layout on larger screens */
         }

         /* Style headings */
         h1 {
            color: #00ffff; /* Cyan headings */
            text-shadow: 0 0 8px #00ffff;
            margin-bottom: 1rem;
         }

         /* Style the message box */
         #messageBox {
            font-weight: bold;
            border-radius: 8px;
            margin-top: 2rem;
         }
         .alert-info {
            background-color: rgba(0, 123, 255, 0.2); /* Semi-transparent blue */
            border-color: #007bff;
            color: #b8daff;
         }
         .alert-success {
             background-color: rgba(40, 167, 69, 0.2); /* Semi-transparent green */
             border-color: #28a745;
             color: #c3e6cb;
         }
          .alert-danger {
             background-color: rgba(220, 53, 69, 0.2); /* Semi-transparent red */
             border-color: #dc3545;
             color: #f5c6cb;
         }

    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top mb-4">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">ðŸŒŒ BREAKOUT: NEBULA</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <span class="nav-link active">SCORE: <span id="score">0</span></span>
                    </li>
                    <li class="nav-item">
                        <span class="nav-link active">LIVES: <span id="lives">3</span></span>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container text-center">
        <h1 class="mt-4">Futuristic Breakout</h1>

        <canvas id="gameCanvas"></canvas>

        <div class="game-controls mt-3">
            <button id="startButton" class="btn">Start Game</button>
            <button id="resetButton" class="btn">Reset Game</button>
        </div>

        <div id="messageBox" class="alert alert-info mt-4 d-none" role="alert">
            Game Message Will Appear Here
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        // --- Canvas and Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Elements Dimensions (relative sizes, adjusted in setCanvasSize) ---
        let ballRadius = 10;
        let paddleHeight = 12;
        let paddleWidth = 95;

        // --- Brick Configuration ---
        const brickRowCount = 4;
        const brickColumnCount = 6;
        const brickWidthBase = 75; // Base width, scaled later
        const brickHeight = 20;
        const brickPadding = 12;
        const brickOffsetTop = 40;
        const brickOffsetLeftBase = 30; // Base offset, scaled later

        // --- Game Element Positions and Speed ---
        let x, y, dx, dy, paddleX; // Initialized in resetBallAndPaddle / setCanvasSize

        // --- Bricks Array ---
        const bricks = [];
        // Initialize bricks structure
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                // status 1 = active, 0 = broken
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        // --- Controls State ---
        let rightPressed = false;
        let leftPressed = false;

        // --- Game State Variables ---
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let animationFrameId; // To control the game loop

        // --- DOM Element References ---
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const messageBox = document.getElementById('messageBox');

        // --- Event Listeners Setup ---
        document.addEventListener('keydown', keyDownHandler, false);
        document.addEventListener('keyup', keyUpHandler, false);
        document.addEventListener('mousemove', mouseMoveHandler, false);
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);

        // --- Core Functions ---

        /**
         * Handles key down events for paddle control.
         * @param {KeyboardEvent} e - The keyboard event.
         */
        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        /**
         * Handles key up events for paddle control.
         * @param {KeyboardEvent} e - The keyboard event.
         */
        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        /**
         * Handles mouse movement for paddle control.
         * @param {MouseEvent} e - The mouse event.
         */
        function mouseMoveHandler(e) {
            // Calculate mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const root = document.documentElement;
            const relativeX = e.clientX - rect.left - root.scrollLeft;

            // Move paddle if mouse is within canvas bounds
            if (relativeX > 0 && relativeX < canvas.width) {
                paddleX = relativeX - paddleWidth / 2;
                // Constrain paddle within canvas bounds
                if (paddleX < 0) paddleX = 0;
                if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
            }
        }

        /**
         * Detects collisions between the ball and bricks.
         */
        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    // Check only active bricks
                    if (b.status === 1) {
                        // Simple AABB collision check
                        if (
                            x + ballRadius > b.x && // Ball's right edge past brick's left edge
                            x - ballRadius < b.x + b.width && // Ball's left edge before brick's right edge
                            y + ballRadius > b.y && // Ball's bottom edge past brick's top edge
                            y - ballRadius < b.y + brickHeight // Ball's top edge before brick's bottom edge
                        ) {
                            dy = -dy; // Reverse ball's vertical direction
                            b.status = 0; // Mark brick as broken
                            score++; // Increment score
                            updateScore(); // Update score display

                            // Check for win condition
                            if (score === brickRowCount * brickColumnCount) {
                                showMessage('YOU WIN! CONGRATULATIONS!', 'success');
                                stopGame();
                            }
                        }
                    }
                }
            }
        }

        /**
         * Draws the ball on the canvas with a neon effect.
         */
        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            // Neon glow effect for the ball
            ctx.fillStyle = '#00ffff'; // Cyan ball color
            ctx.shadowColor = '#00ffff'; // Cyan shadow for glow
            ctx.shadowBlur = 15; // Intensity of the glow
            ctx.fill();
            ctx.closePath();
            // Reset shadow blur for other elements
            ctx.shadowBlur = 0;
        }

        /**
         * Draws the paddle on the canvas with a gradient.
         */
        function drawPaddle() {
            ctx.beginPath();
            // Use paddleX calculated based on mouse/keyboard input
            ctx.rect(paddleX, canvas.height - paddleHeight - 5, paddleWidth, paddleHeight); // Position slightly above bottom
            // Gradient fill for the paddle
            const gradient = ctx.createLinearGradient(paddleX, canvas.height - paddleHeight - 5, paddleX + paddleWidth, canvas.height - 5);
            gradient.addColorStop(0, '#007bff'); // Blue start
            gradient.addColorStop(1, '#00ffff'); // Cyan end
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.closePath();
        }

        /**
         * Draws the bricks on the canvas with futuristic colors.
         */
        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    // Only draw active bricks
                    if (bricks[c][r].status === 1) {
                        const brickX = bricks[c][r].x; // Use pre-calculated positions
                        const brickY = bricks[c][r].y;
                        const brickW = bricks[c][r].width; // Use pre-calculated width

                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickW, brickHeight);
                        // Style bricks with vibrant futuristic colors based on row
                        switch (r % 4) { // Cycle through 4 colors
                            case 0: ctx.fillStyle = '#ff00ff'; break; // Magenta
                            case 1: ctx.fillStyle = '#ff8c00'; break; // DarkOrange
                            case 2: ctx.fillStyle = '#ffd700'; break; // Gold
                            case 3: ctx.fillStyle = '#00ff7f'; break; // SpringGreen
                        }
                         ctx.shadowColor = ctx.fillStyle; // Match shadow to fill
                         ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.closePath();
                        ctx.shadowBlur = 0; // Reset shadow
                    }
                }
            }
        }

        /** Updates the score display in the navbar. */
        function updateScore() {
            scoreElement.textContent = score;
        }

        /** Updates the lives display in the navbar. */
        function updateLives() {
            livesElement.textContent = lives;
        }

        /**
         * Shows a message to the user in the designated message box.
         * @param {string} msg - The message to display.
         * @param {string} [type='info'] - The type of message (Bootstrap alert class: 'info', 'success', 'danger').
         */
        function showMessage(msg, type = 'info') {
            messageBox.textContent = msg;
            // Update Bootstrap alert classes
            messageBox.className = `alert alert-${type} mt-4`;
            // Make the message box visible
            messageBox.classList.remove('d-none');
        }

        /** Hides the message box. */
        function hideMessage() {
            messageBox.classList.add('d-none');
        }

        /** Resets the ball and paddle to their starting positions. */
        function resetBallAndPaddle() {
             x = canvas.width / 2;
             y = canvas.height - paddleHeight - ballRadius - 10; // Start above paddle
             // Randomize initial horizontal direction and speed slightly
             dx = (Math.random() < 0.5 ? 1 : -1) * (canvas.width / 300 + Math.random() * 0.5); // Speed relative to width
             dy = -(canvas.height / 150 + Math.random() * 0.5); // Speed relative to height
             paddleX = (canvas.width - paddleWidth) / 2; // Center paddle
        }

        /**
         * Resets the entire game state to the beginning.
         */
        function resetGame() {
            stopGame(); // Stop any current game loop
            score = 0;
            lives = 3;
            updateScore();
            updateLives();
            resetBallAndPaddle(); // Position ball and paddle

            // Reset bricks status and recalculate positions based on current canvas size
            calculateBrickPositions(); // Ensure bricks are positioned correctly for the current size

            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r].status = 1; // Reactivate all bricks
                }
            }
            hideMessage(); // Clear any previous messages
            gameRunning = false; // Mark game as not running
            startButton.disabled = false; // Re-enable start button

            // Draw the initial state (clears canvas and draws elements)
            clearCanvas();
            drawBricks();
            drawPaddle();
            drawBall();
        }

        /** Starts the game loop. */
        function startGame() {
            // Prevent starting if already running
            if (!gameRunning) {
                // If starting from game over or win state, reset first
                if (lives <= 0 || score === brickRowCount * brickColumnCount) {
                    resetGame();
                }
                gameRunning = true;
                startButton.disabled = true; // Disable start button while playing
                hideMessage(); // Hide any messages
                // Ensure ball/paddle are positioned correctly if starting fresh
                if (score === 0 && lives === 3) {
                   resetBallAndPaddle();
                }
                // Start the animation loop
                draw();
            }
        }

        /** Stops the game loop and cancels the animation frame. */
        function stopGame() {
             gameRunning = false; // Mark game as stopped
             startButton.disabled = false; // Re-enable start button
             // Cancel the next animation frame request if it exists
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }
        }

        /** Clears the entire canvas. */
        function clearCanvas() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
        }


        /**
         * The main game loop function. Clears canvas, draws elements,
         * handles movement, collisions, and requests the next frame.
         */
        function draw() {
            // Stop the loop if the game isn't running
            if (!gameRunning) return;

            // Clear canvas for the new frame
            clearCanvas();

            // Draw all game elements
            drawBricks();
            drawBall();
            drawPaddle();

            // Check for collisions between ball and bricks
            collisionDetection();

            // --- Ball Movement and Wall Collision Logic ---

            // Bounce off left/right walls
            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
                dx = -dx; // Reverse horizontal direction
            }

            // Bounce off top wall
            if (y + dy < ballRadius) {
                dy = -dy; // Reverse vertical direction
            }
            // Check for collision with paddle or bottom wall
            else if (y + dy > canvas.height - ballRadius - paddleHeight - 5) { // Check near paddle height zone
                // Check if ball is horizontally aligned with the paddle
                if (x > paddleX && x < paddleX + paddleWidth) {
                     dy = -dy; // Bounce off the paddle
                     // Optional: Add angle change based on hit location on paddle
                     let deltaX = x - (paddleX + paddleWidth / 2);
                     dx = deltaX * 0.15; // Adjust horizontal speed/angle based on hit position
                } else if (y + dy > canvas.height - ballRadius) { // Ball hit the bottom wall
                    lives--; // Lose a life
                    updateLives(); // Update lives display
                    if (lives <= 0) {
                        // Game Over
                        showMessage('GAME OVER!', 'danger');
                        stopGame();
                        // Exit draw loop immediately after game over
                        return;
                    } else {
                        // Reset ball and paddle for the next life
                        resetBallAndPaddle();
                    }
                }
            }


            // --- Paddle Movement Logic ---
            // Move paddle based on key press state, constrained within canvas
            if (rightPressed && paddleX < canvas.width - paddleWidth) {
                paddleX += 7; // Paddle speed
            } else if (leftPressed && paddleX > 0) {
                paddleX -= 7; // Paddle speed
            }

            // Update ball position for the next frame
            x += dx;
            y += dy;

            // Request the next frame for smooth animation
            animationFrameId = requestAnimationFrame(draw);
        }

        /** Calculates and sets the positions and sizes of bricks based on canvas size. */
        function calculateBrickPositions() {
            // Calculate available width for bricks, considering offsets and padding
            const totalPaddingWidth = (brickColumnCount + 1) * brickPadding;
            const availableWidth = canvas.width - 2 * brickOffsetLeftBase - totalPaddingWidth;
            const dynamicBrickWidth = availableWidth / brickColumnCount;

            // Calculate the actual offset needed to center the bricks horizontally
            const actualOffsetLeft = (canvas.width - (brickColumnCount * (dynamicBrickWidth + brickPadding) - brickPadding)) / 2;


            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (!bricks[c][r]) bricks[c][r] = {}; // Ensure brick object exists
                    bricks[c][r].width = dynamicBrickWidth; // Store dynamic width
                    bricks[c][r].x = actualOffsetLeft + c * (dynamicBrickWidth + brickPadding);
                    bricks[c][r].y = brickOffsetTop + r * (brickHeight + brickPadding);
                }
            }
        }


        /**
         * Sets the canvas dimensions based on the container width,
         * adjusts game element sizes proportionally, and resets the game.
         */
        function setCanvasSize() {
            // Get the width of the container element (minus some padding)
            const containerWidth = canvas.parentElement.offsetWidth - 30; // Reduce width slightly for padding
            // Set canvas width, respecting a maximum width
            canvas.width = Math.min(containerWidth, 800); // Max width 800px
            // Set canvas height based on a fixed aspect ratio (e.g., 2:1 or 16:9)
            canvas.height = canvas.width * 0.5; // Example: 2:1 aspect ratio

            // Adjust game element sizes relative to canvas size
            ballRadius = canvas.width / 60; // Ball size relative to width
            paddleWidth = canvas.width / 8; // Paddle width relative to width
            paddleHeight = canvas.height / 35; // Paddle height relative to height

            // Recalculate brick positions and sizes
            calculateBrickPositions();

            // Reset game state with new sizes and positions
            resetGame();
        }

        // --- Initial Setup on Load and Resize ---

        // Set initial canvas size and draw initial state when the window loads
        window.onload = () => {
            setCanvasSize(); // Set size, which also calls resetGame()
        };

        // Adjust canvas size and reset game when the window is resized
        window.onresize = () => {
            setCanvasSize(); // Resize canvas and reset game elements
        };

    </script>
</body>
</html>
